import * as anchor from "@coral-xyz/anchor";
import { BN, Program } from "@coral-xyz/anchor";
import { AnchorEscrowProgram } from "../target/types/anchor_escrow_program";
import { expect } from "chai";
import { PublicKey, ConfirmOptions, LAMPORTS_PER_SOL } from "@solana/web3.js";
import {
  getAssociatedTokenAddressSync,
  createMint,
  mintTo,
  TOKEN_PROGRAM_ID,
  createAssociatedTokenAccount,
  getAccount,
} from "@solana/spl-token";
import * as path from "path";
import { Keypair } from "@solana/web3.js";
import * as fs from "fs";
const confirmOpts: ConfirmOptions = {
  commitment: "confirmed",
}

// maker_publicKey = QjbtoYq1DzaESV4Yd4VxGaTrqwLb6mYRLonVNHLodcH
// taker_publicKey = Bo7t8iDX4K4bESxqAD5C86ntRv9SMErUpZHq9cWBkfiW

// const USDC_MINT = new PublicKey("4zMMC9srt5Ri5X14GAgXhaHii3GnPAE2kkf72MpCJ9tv");
// const USDT_MINT = new PublicKey("Es9vMFrzaCERmJfrF4H2rG1LU68AQcBz1MUV5vSKx9A8");

// function loadKeypair(name: string): Keypair {
//   const filePath = path.join(__dirname, "fixtures", `${name}.json`);
//   const raw = JSON.parse(fs.readFileSync(filePath, "utf-8"));
//   return Keypair.fromSecretKey(new Uint8Array(raw));
// }


describe("anchor-escrow-program", () => {
  // Configure the client to use the local cluster.
  const provider = anchor.AnchorProvider.env();
  anchor.setProvider(anchor.AnchorProvider.env());

  const program = anchor.workspace
    .AnchorEscrowProgram as Program<AnchorEscrowProgram>;

  const connection = provider.connection;

  const maker = Keypair.generate();
  const taker = Keypair.generate();
  let mintA: PublicKey;
  let mintB: PublicKey;
  let makerAtaA: PublicKey;
  let takerAtaB: PublicKey;

  // const maker = loadKeypair("maker");
  // const taker = loadKeypair("taker");
  // const mintA = USDC_MINT;
  // const mintB = USDT_MINT;


  // const makerAtaA = getAssociatedTokenAddressSync(mintA, maker.publicKey);
  // const takerAtaB = getAssociatedTokenAddressSync(mintB, taker.publicKey);


  // let mintA: PublicKey;
  // let mintB: PublicKey;
  // let makerAtaA: PublicKey;
  // let takerAtaB: PublicKey;

  let makerAtaB: PublicKey;
  let takerAtaA: PublicKey;

  const seed = new anchor.BN(1);

  const depositAmount = new BN(10_000_000);
  const receiveAmount = new BN(50_000_000);
  const decimals = 6;

  async function airdrop(to: PublicKey, amount: number) {
    const lastestBlockhash = await connection.getLatestBlockhash();
    const sig = await connection.requestAirdrop(to, amount);
    await connection.confirmTransaction(
      { signature: sig, ...lastestBlockhash },
      "confirmed"
    )
  }

  function getEscrowPda(makerKey: PublicKey, escrowSeed: BN): PublicKey {
    return anchor.web3.PublicKey.findProgramAddressSync(
      [
        Buffer.from("escrow"),
        makerKey.toBuffer(),
        escrowSeed.toArrayLike(Buffer, "le", 8),
      ],
      program.programId,
    )[0];
  }

function getVaultAta(escrow: PublicKey, mint: PublicKey): PublicKey {
  return getAssociatedTokenAddressSync(mint, escrow, true)
}

before(async () => {
  await airdrop(maker.publicKey, 10 * LAMPORTS_PER_SOL)
  await airdrop(taker.publicKey, 10 * LAMPORTS_PER_SOL)

  mintA = await createMint(
    connection,
    maker,
    maker.publicKey,
    null,
    decimals,
    undefined,
    confirmOpts,

  );

  mintB = await createMint(
    connection,
    maker,
    maker.publicKey,
    null,
    decimals,
    undefined,
    confirmOpts,

  );

  makerAtaA = await createAssociatedTokenAccount(
    connection,
    maker,
    mintA,
    maker.publicKey,
    confirmOpts,
    
  );

  takerAtaB = await createAssociatedTokenAccount(
    connection,
    taker,
    mintB,
    taker.publicKey,
    confirmOpts,
    
  );

 
  takerAtaA = await createAssociatedTokenAccount(
    connection,
    taker,
    mintA,
    taker.publicKey,
    confirmOpts,
    
  );

   makerAtaB = await createAssociatedTokenAccount(
    connection,
    maker,
    mintB,
    maker.publicKey,
    confirmOpts,
    
  );

  await mintTo(
    connection,
    maker,
    mintA,
    makerAtaA,
    maker,
    100_000_000,
    undefined,
    confirmOpts,
  );

  await mintTo(
    connection, 
    maker,
    mintB,
    makerAtaB,
    maker,
    100_000_000,
    undefined,
    confirmOpts,
  );


});



it("make", async () => {
  const escrow = getEscrowPda(maker.publicKey, seed);
  const vault = getVaultAta(escrow, mintA);

  await program.methods.make(seed, depositAmount, receiveAmount)
    .accountsPartial({
      maker: maker.publicKey,
      mintA,
      mintB,
      makerAtaA,
      escrow,
      vault,
      tokenProgram: TOKEN_PROGRAM_ID,
    })
    .signers([maker])
    .rpc(confirmOpts);

    const escrowAccount = await program.account.escrow.fetch(escrow);
    expect(escrowAccount.seeds.toNumber()).to.equal(seed.toNumber());
    expect(escrowAccount.maker.toBase58()).to.equal(maker.publicKey.toBase58());
    expect(escrowAccount.mintA.toBase58()).to.equal(mintA.toBase58());
    expect(escrowAccount.mintB.toBase58()).to.equal(mintB.toBase58());
    expect(escrowAccount.receive.toNumber()).to.equal(receiveAmount.toNumber());
  

    const vaultAccount = await getAccount(connection, vault);
    expect(Number(vaultAccount.amount)).to.equal(depositAmount.toNumber());

});



it("take", async () => {
  const escrow = getEscrowPda(maker.publicKey, seed);
  const vault = getVaultAta(escrow, mintA);

  await program.methods.make
});

describe("refund", () => {
  before(async () => {});

  it("", async () => {})
})

})




